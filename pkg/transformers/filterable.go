package transformers

import (
	"github.com/urfave/cli"
	"github.com/vapor-ware/synse-cli/pkg/transformers/filters"
)

// Filterable implements function-based filtering in order to filter the
// Transformer Items.
type Filterable struct {
	// The slice of items to filter. When called via Filter from the
	// Transformer, it will be the Items of the Transformer.
	toFilter []interface{}

	// The filters to use when filtering. These should be generated from
	// the values provided by the --filter flag of the command cli.Context
	// via the SetFilters function.
	filters []*filters.Filter

	// A map containing the possible FilterFunc filters for the command.
	// Here, the key corresponds to the filter key passed in via the filter
	// flag for a command.
	filterSet map[string]filters.FilterFunc
}

// filter filters the toFilter slice according to the filter functions defined by
// the configured filters. This is not exported, as it is intended to only be
// called by the Transformer that it extends.
func (f *Filterable) filter() []interface{} {
	filtered := make([]interface{}, 0)
	for _, item := range f.toFilter {
		for _, filter := range f.filters {
			fn := f.filterSet[filter.Key]
			if fn != nil {
				if fn(item, filter.Value) {
					filtered = append(filtered, item)
				}
			}
		}
	}
	return filtered
}

// SetFilters populates the filters field with a slice of Filters generated by
// parsing the cli.Context's --filter flag value(s), if it exists.
func (f *Filterable) SetFilters(c *cli.Context) error {
	cmdFilters := c.StringSlice("filter")
	for _, filterString := range cmdFilters {
		filter, err := filters.NewFilter(filterString)
		if err != nil {
			return err
		}
		f.filters = append(f.filters, filter)
	}
	return nil
}
