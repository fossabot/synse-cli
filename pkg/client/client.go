// Package client extends the https://github.com/dghubble/sling package to provide a
// RESTful client to the Synse endpoints. The base url path is constructed
// from the configured Synse url as well as the type and version of the API.
// All new queries within synse should be using an instance of this client.
package client

import (
	"fmt"
	"net/http"
	"time"

	"strings"

	log "github.com/Sirupsen/logrus"
	"github.com/dghubble/sling"
	"github.com/urfave/cli"
	"github.com/vapor-ware/synse-cli/pkg/config"
	"github.com/vapor-ware/synse-cli/pkg/scheme"
)

// constructURL builds the full url string from the host base, endpoint type
// (Synse), and API version number. Endpoint paths can be extended off of
// this base.
func constructURL(host string) string {
	version := &scheme.Version{}
	err := DoGetUnversioned("version", version)
	if err != nil {
		log.Error("failed to get API version of Synse Server instance")
		cli.OsExiter(1)
	}
	return fmt.Sprintf("http://%s/synse/%s/", host, version.APIVersion)
}

// ErrorResponse contains the possible response data from an API error.
type ErrorResponse struct { // FIXME: This should go somewhere else
	HTTPCode int    `json:"http_code"`
	Message  string `json:"message"`
}

// LogMiddleware wraps the http.Client object to log messages generated by queries.
type LogMiddleware struct {
	c http.Client
}

// Do wraps the http.Request.Do object to log any messages during calls.
func (d LogMiddleware) Do(req *http.Request) (*http.Response, error) {
	log.WithFields(log.Fields{
		"method": req.Method,
		"url":    fmt.Sprintf("%v", req.URL),
		// We're not doing anything with headers or forms yet. Once we do, turn
		// these on.
		// ----
		// "header": fmt.Sprintf("%v", req.Header),
		// "form": fmt.Sprintf("%v", req.Form),
	}).Debug("request: start")

	start := time.Now()
	resp, err := d.c.Do(req)
	elapsed := time.Since(start)

	status := ""
	if resp != nil {
		status = resp.Status
	}

	log.WithFields(log.Fields{
		"duration": elapsed,
		"url":      fmt.Sprintf("%v", req.URL),
		"status":   status,
	}).Debug("request: complete")

	return resp, err
}

// NewUnversioned generates a new instance of the Client for the un-versioned base endpoint.
func NewUnversioned() *sling.Sling {
	return sling.New().Doer(&LogMiddleware{}).Base(fmt.Sprintf("http://%s/synse/", config.Config.ActiveHost.Address)).New()
}

// New generates a new instance of the Client with the current configuration.
func New() *sling.Sling {
	return sling.New().Doer(&LogMiddleware{}).Base(constructURL(config.Config.ActiveHost.Address)).New()
}

// check is a helper function to check the HTTP response from Synse Server.
// If the request failed with error or returned an error code, it will raise
// an error.
func check(response *http.Response, err error) error {
	if err != nil {
		return cli.NewExitError(err, 1)
	}

	if response.StatusCode != http.StatusOK {
		// TODO (etd) - Synse Server returns JSON for 404 and 500 - we should check
		// that here/log it out.
		return cli.NewExitError(
			fmt.Sprintf("got HTTP code %v for request", response.StatusCode),
			1,
		)
	}
	return nil
}

// MakeURI joins the given components into a string, delimited with '/' which
// can then be used as the URI for API requests.
func MakeURI(components ...string) string {
	return strings.Join(components, "/")
}

// DoGet is a convenience function which performs a GET request against the
// Synse Server versioned API.
func DoGet(uri string, scheme interface{}) error {
	return check(New().Get(uri).ReceiveSuccess(scheme))
}

// DoGetUnversioned is a convenience function which performs a GET request against
// the Synse Server unversioned API.
func DoGetUnversioned(uri string, scheme interface{}) error {
	return check(NewUnversioned().Get(uri).ReceiveSuccess(scheme))
}

// DoPost is a convenience function which perfoms a POST request against the
// Synse Server versioned API.
func DoPost(uri string, body interface{}, scheme interface{}) error {
	return check(New().Post(uri).BodyJSON(body).ReceiveSuccess(scheme))
}
